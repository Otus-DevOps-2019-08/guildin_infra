 ./gcloud auth application-default login
Your browser has been opened to visit:

    https://accounts.google.com/o/oauth2/auth?code_challenge=ji1Ohqa8laLLD0Bs_Gs0Y0l0Q5x7Icec7B-DnE-oqnk&prompt=select_account&code_challenge_method=S256&access_type=offline&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&response_type=code&client_id=764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com&scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth



Credentials saved to file: [/home/guildin/.config/gcloud/application_default_credentials.json]




...


# Ansible-1

## Установка ansible
sudo apt install python-pip
echo "ansible>=2.4" > requirements.txt
pip install -r requirements.txt

Не катит. Тогда:
```
sudo apt-get install python-setuptools ansible
```
apt без вопросов поставит ansible 2.2, а потом накатываем через этот ваш pip версию больше 2.4, а конкретно ansible 2.8.6.

  * Развернем stage версию окружения:
```cd ../terraform/stage && terraform apply```
  * Получим outputs и:
~/  ansible$ echo "appserver ansible_host=X.X.X.X ansible_user=appuser ansible_private_key_file=~/.ssh/appuser" > inventory


тестовый запуск:
```
ansible appserver -i ./inventory -m ping
The authenticity of host '23.251.128.237 (23.251.128.237)' can't be established.
ECDSA key fingerprint is SHA256:zXR27pcxoeZYnOZZVoKqT3UI39qR6zqYH8J/0AE17Po.
Are you sure you want to continue connecting (yes/no)? yes
[DEPRECATION WARNING]: Distribution Ubuntu 16.04 on host appserver should use /usr/bin/python3, but is using /usr/bin/python for backward compatibility with prior 
Ansible releases. A future Ansible release will default to using the discovered platform python for this host. See 
https://docs.ansible.com/ansible/2.8/reference_appendices/interpreter_discovery.html for more information. This feature will be removed in version 2.12. Deprecation 
warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.
appserver | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

по аналогии добавим данные для подключения к северу БД
```
dbserver ansible_host=Y.Y.Y.Y ansible_user=appuser ansible_private_key_file=~/.ssh/appuser
```
Зададим настройки для подключения по умолчанию (ansible.cfg):
```
[defaults]
inventory = ./inventory
remote_user = appuser
private_key_file = ~/.ssh/appuser
host_key_checking = False
retry_files_enabled = False
```
После этого приведем inventory к следующему виду:
```
appserver ansible_host=X.X.X.X
dbserver ansible_host=Y.Y.Y.Y
```

Проверим работу:
```ansible dbserver -m command -a uptime```
[DEPRECATION WARNING]: Distribution Ubuntu 16.04 on host dbserver should use /usr/bin/python3, but is using /usr/bin/python for backward compatibility with prior 
Ansible releases. A future Ansible release will default to using the discovered platform python for this host. See 
https://docs.ansible.com/ansible/2.8/reference_appendices/interpreter_discovery.html for more information. This feature will be removed in version 2.12. Deprecation 
warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.
dbserver | CHANGED | rc=0 >>
 21:52:11 up 14 min,  1 user,  load average: 0.00, 0.02, 0.06

### Ansible. Работа с группами хостов
[app]
appserver ansible_host=23.251.128.237 
dbserver ansible_host=34.77.203.234 

Проверка:
```ansible app -m ping```

### [Документация по  inventory](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html)


ansible app -m _command_ -a 'ruby -v; bundler -v' -i inventory.yml - _ не сработает_
ansible app -m shell -a 'ruby -v; bundler -v' -i inventory.yml - _сработает_
Модуль command выполняет команды, не используя оболочку(sh, bash), поэтому в нем не работают перенаправления потокови нет доступа к некоторым переменным окружения.

### Выполнение команд
  * 
```ansible db -m *command* -a 'systemctl status mongod' -i inventory.yml```
```ansible db -m *systemd* -a name=mongod -i inventory.yml```
```ansible db -m *service* -a name=mongod -i inventory.yml```
  * Установка git:
```ansible app -m git -a 'repo=https://github.com/express42/reddit.git dest=/home/appuser/reddit'```
При повторном запуске возвращает результат SUCCESS c параметром changed: false
### Первый плейбук:
```
---
- name: Clone
  hosts: app
  tasks:
    - name: Clone repo
      git:
        repo: https://github.com/express42/reddit.git
        dest: /home/appuser/reddit
```

Попробуем запустить:
```ansible-playbook clone.yml```
appserver                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
--- Второй запуск
```ansible-playbook clone.yml```
appserver                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
--- Третий запуск после удаления на целевой группе папки реддит
```ansible app -m command -a ' rm -rf ~/reddit' && ansible-playbook clone.yml```
appserver                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   


## Задание с Ж
[Заметка про json в ансибл (или наоборот)](https://medium.com/@Nklya/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B2%D0%B5%D0%BD%D1%82%D0%BE%D1%80%D0%B8-%D0%B2-ansible-9ee880d540d6)
  * Попробуем сформировать json inventory с подобной структурой: 
```
{
  "all": {
    "children": {
    "apps": {
        "hosts": {
          "35.241.204.244": null
        }
      },
      "dbs": {
        "hosts": {
          "23.251.128.237": null
        }
      }
    }
  }
}
```
  * Тестирование:
```ansible -i static-inv.json all -m ping```
Что же, статическое inventory работает.

  * Для динамического inventory используем GCP плагин для ansible (далее inventory.gcp.yml):
```
plugin: gcp_compute
auth_kind: serviceaccount
service_account_file: "~/.ssh/infra-40b9617a4128.json" #credential, полученный через консоль. Через gcloud tool не стал, не так то часто забираешь ключи от машины.
regions:
  - eu-west1-b
projects:
  - infra-253310
hostnames:
  - public_ip # Из какого тега забрать имя хоста
compose:
  ansible_host: networkInterfaces[0].accessConfigs[0].natIP
```

  * Сошлемся на него в ansible.cfg, чтобы каждый раз не указывать. Можно даже попробовать:
```ansible all --list```
  hosts (2):
    35.241.204.244
    23.251.128.237
Это замечательно, это работает, это не json. Ну хорошо. ansible-inventory умеет в json:
```ansible-inventory --export --list``` > inventory.json
Да, мы сразу положили все-все-все в файл. Но значимые данные на текущий момент имеют следующую структуру:
```json
{
    "_meta": {
        "hostvars": {
            "23.251.128.237": {                         
                "ansible_host_natip": "23.251.128.237", 
                "name": "reddit-db", 
                "project": "infra-253310", 
                "tags": {
                    "items": [
                        "reddit-db"
                    ]
                }, 
                "zone": "europe-west1-b", 
            }, 
            "35.241.204.244": {
                "ansible_host_natip": "35.241.204.244", 
                "name": "reddit-app", 
                "project": "infra-253310", 
                "tags": {
                    "items": [
                        "http-server", 
                        "reddit-app"
                    ]
                }, 
                "zone": "europe-west1-b", 
            }
        }
    }, 
    "all": {
        "children": [
            "ungrouped"
        ]
    }, 
    "ungrouped": {
        "hosts": [
            "23.251.128.237", 
            "35.241.204.244"
        ]
    }
}
```

В соответствии со статьей нужно сделать следующее:
1. Динамическое инвентори представляет собой простой исполняемый скрипт (+x), который при запуске с параметром --list возвращает список хостов в формате JSON.
2. При запуске скрипта с параметром --host <hostname> (где <hostname> это один из хостов), скрипт должен вернуть JSON с переменными для этого хоста. Поддержка этой опции необязательно, скрипт может просто вернуть пустой список. 

Для работы с json возьмем утилиту jq.
Ей передадим inventory.json, формирующийся с помощью плагина gcp_compute (подробнее в файле inventory.gcp.yml)
Осталось только добавить немножко функций и обработчик (в виде, описанном в статье) готов:
```
#!/bin/bash

function getHost () {
	if [[ -n $1 ]]
	then
		printf "getting data for host $1  \n"
		cat inventory.json | jq '._meta.hostvars['\"$1\"']' # Выгружается вся нода хоста, я не стал ее фильтровать, хотя мог бы. Но ансиблу должно быть все равно, есть ли другие параметры.
	else
		printf "No hostname specified!"
	fi
	}

function getList() {
	cat inventory.json | jq '. | {hosts: .ungrouped.hosts}'
	}

#Грузим джейсона простыней от GCP
ansible-inventory -i inventory.gcp.yml --list --export > inventory.json
#(реально страшная простыня)

echo
while [ -n "$1" ]
do
	case "$1" in
		--list) getList ;;
		--host) getHost $2 ;;
		--help) printf "usage: jinventory.sh ARGS\n --list - перечень хостов в инвентори \n --host [hostname] - выдать json-данные по этому хосту.\n";;
	esac
	shift
done
```
